#<?cfg paf policy ?>
# Default Image Subtraction Policy File

####################################
# Write intermediate FITS files? (boolean)
#
debugIO: false
debugPlot: false



####################################
# ASTROMETRICALLY WARPING THE TEMPLATE IMAGE TO MATCH THE SCIENCE IMAGE
#
######
# Warping kernel for warping template Exposure
#
# Options are : bilinear, lanczos#
#
warpingKernelName: "lanczos4"



####################################
# RUNNING DETECTION TO FIND GOOD FOOTPRINTS
#
######
# Minimum number of pixels in an acceptible Footprint
#
fpNpixMin: 5

######
# Maximum number of pixels in an acceptible Footprint
#
# Too big and the subsequent convolutions become unwieldy 
#
fpNpixMax: 500

######
# Run detection on the template (imageToConvolve; value = true) or
# science image (imageToNotConvolve; value = false)
#
detOnTemplate: true

######
# Mask planes that lead to an invalid detection
#
# Options: EDGE SAT BAD CR INTRP
# 
# E.g. : EDGE SAT BAD allows CR-masked and interpolated pixels
#
detBadMaskPlanes: "EDGE" "SAT" "BAD"

######
# Grow each raw detection footprint by this many pixels
#
# The smaller the faster; however the kernel sum does not converge if
# the stamp is too small; and the kernel is not constrained at all if
# the stamp is the size of the kernel.  Rule of thumb is at least 1.5
# times the kernel size
#
# The grown stamp is ~2*fpGrowPix pixels larger in each dimension.
#
fpGrowPix: 30

######
# Threshold in Sigma or Signal detection?
#
# Allowed values : value, stdev, variance
#
detThresholdType: "stdev"

######
# Threshold 
#
# Initial detection threshold (if high, this is for debugging)
#
# For standard processing a value like 10 would be acceptable when
# detecting on a template, 5 for on a science image
# 
detThreshold: 10.


####################################
# BASIS SET FOR KERNEL FITTING
#
######
# Type of basis set for PSF matching kernel
#
# Options are : delta-function, alard-lupton
#
# If alard-lupton is used, the first term will have no spatial
# variation and the kernel sum will be conserved.  If delta-function
# is used, you have the option to "useRegularization", and might also
# want to seriously consider "usePcaForSpatialKernel" which will also
# enable kernel sum conservation for the delta function kernels.
#
# Delta function, even regularized, do not work well for convolving
# single-depth images.
#
# NOTE : if "alard-lupton" you might want to turn off
# "usePcaForSpatialKernel" down below.  
#
kernelBasisSet: "alard-lupton"

######
# Size of the convolution kernel
#
# For delta function kernels there are kernelRows.x.kernelCols bases
# For alard lupton kernel, the half width is kernelRows//2, kernelCols//2
#
kernelRows: 19
kernelCols: 19

######
# Default Alard-Lupton Parameters
# 
# Note that the widths are in sigma, not FWHM (FWHM = 2.35 sigma)
# len(alardSigGauss) and len(alardDegGauss) must equal alardNGauss
#
alardNGauss:   3
alardSigGauss: 0.7 1.5 3.0
alardDegGauss: 4   3   2

######
# Scaling of these numbers with the Psf Fwhm
#
# Value of 4.0 works for alard-lupton basis; need something larger for
# delta-function
#
fpGrowFwhmScaling: 4.0
fpGrowMin: 20
fpGrowMax: 40

kernelRadiusFwhmScaling: 2.5
kernelRadiusMin: 7
kernelRadiusMax: 15

# Scaling of the AL gaussian "sigmas" by Fwhm/2.35
alardSigFwhmScaling: 0.50 1.00 2.00


######
# Regularization used with delta-function kernel basis set to enfore
# smoothness and self-similarity
#
# regularizationType : centralDifference (penalizes second derivative using 2-D stencil)
#                      forwardDifference (penalizes first, second, third or combination of derivatives)
# centralRegularizationStencil : for central difference, 5 or 9 point stencil
# forwardRegularizationOrders  : array showing which order derivatives to penalize
# regularizationBorderPenalty  : penalty for value of kernel along its border
# regularizationScaling        : fraction of the default lambda strength (N.R. 18.5.8) to use. 
#                                somewhere around 1e-4 to 1e-5 seems to work.
#                                some kernels need high freq power
# regularizationConditionTolerance : for biased risk, what is the ratio of largest eValue to
#                                    the smallest you want to keep         
#
useRegularization: true
regularizationType: centralDifference
centralRegularizationStencil: 9
forwardRegularizationOrders: 1 2 
regularizationBorderPenalty: 3.
regularizationConditionTolerance: 1.e5
######
# How to choose the value of Lambda
#  
# lambdaType = "absolute" : use lambdaValue as the value of lambda
#            = "relative" : use lambdaValue as a fraction of the default lambda strength (N.R. 18.5.8)
#            = "minimizeBiasedRisk" : minimize biased risk estimate
#            = "minimizeUnbiasedRisk" : minimize unbiased risk estimate
#            = "minimizeGcv" : minimize generalized cross-validation statistic; scan lambda
# 
lambdaType: "absolute" 
lambdaValue: 1.0
lambdaStepType: "log" # "linear"
lambdaLinMin: 1.
lambdaLinMax: 500.0
lambdaLinStep: 10.
lambdaLogMin: -3.
lambdaLogMax: +2.
lambdaLogStep: 0.1

#lambdaType: "relative"
#lambdaValue: 0.00001



####################################
# KERNEL QUALITY CONTROL
#
######
# Rejects objects with deviant Kernel Sums
#
#
maxKsumSigma: 3.0

######
# Rejects objects with bad difference image quality
#
# This is used as a proxy for the quality of the kernel.  We look at
# both the mean value of the residuals in the difference image
# (normalized by the noise; expectation value is 0.0) as well as the
# width of the distribution (expectation value 1.0)
#
# Maximum diffim average of (residual/noise) for an acceptable Kernel
#
candidateResidualMeanMax: 0.25

######
# Maximum diffim standard deviation of (residual/noise) for an acceptable Kernel
#
candidateResidualStdMax: 1.25

######
# What types of sigma clipping to enable
#
# If you want sigma clipping at each step along the way, it should be:
#   singleKernelClipping:  true
#   kernelSumClipping:     true
#   spatialKernelClipping: true
#
# If you only care about the final spatial kernel quality it should be:
#   singleKernelClipping:  false
#   kernelSumClipping:     false
#   spatialKernelClipping: true
# In this case you might want to consider upping "maxSpatialIterations" below
#
singleKernelClipping:  true
kernelSumClipping:     true
spatialKernelClipping: true

######
# Radius for calculation of stats in "core" of KernelCandidate diffim.
# Total number of pixels used will be (2*radius)**2.  This is used
# both for "core" diffim quality as well as ranking of
# KernelCandidates by their total flux in this core 
#
candidateCoreRadius: 3

######

# Maximum condition number when inverting a kernel matrix; anything
# above this is not used and the candidate is set as BAD.  
#
# conditionNumberType: use singular values (SVD) or eigen values (EIGENVALUE)
# maxConditionNumber: maximum values for a "well conditioned matrix.
#                     5.0e6 for "delta-function" basis
#                     5.0e7 for "alard-lupton" basis
#
checkConditionNumber: false
maxConditionNumber: 5.0e7
conditionNumberType: "SVD"


####################################
# SINGLE KERNEL FITTING AROUND 1 SOURCE
#
######
# Remake single kernel using better variance estimate after first pass?
#
# Primarily useful when convolving a single-depth template image,
# otherwise not necessary
#
iterateSingleKernel: false

######
# Use constant variance weighting in single kernel fitting?  
#
# In some cases this is better for bright star residuals
#
constantVarianceWeighting: false

######
# Calculate kernel and background uncertainties for each object?
#
# Comes from inverse of the covariance matrix
# NOTE: Regularization can cause this step problems
#
calculateKernelUncertainty: false

######
# Do you psf match to an idealized Gaussian instead of another image?
#
#
psfMatchToGaussian: false
psfMatchToGaussianSigma1: 3.0
psfMatchToGaussianFlux1: 0.9
psfMatchToGaussianSigma2: 5.0
psfMatchToGaussianFlux2: 0.1




####################################
# SPATIAL KERNEL FITTING
#
######
# Order of kernel and background spatial variation
#
# If you are using a large image, spatialKernelOrder=0, and a constant
# kernel is a bad approximation, you probably want to use the
# following configuration for the sigma clipping above:
#
#   singleKernelClipping:  true
#   kernelSumClipping:     true
#   spatialKernelClipping: false
# 
spatialKernelOrder: 1
spatialBgOrder:     0

######
# Control for background subtraction
# 
# algorithm = how to interpolate the background values
# binsize = how large regions of the sky should be used for each background point
# undersample = what do do if there are not enough regions for the interpolation
#
backgroundPolicy: {
    algorithm:  "NATURAL_SPLINE" 
    binsize:    512
    undersample: "REDUCE_INTERP_ORDER"
}

######
# Include terms (including kernel cross terms) for background
# 
fitForBackground: true

######
# Control if we use afwMath.BackgroundControl to subtract off its own
# determination of the background or not
# 
useAfwBackground: false

#####
# Chops up the image into cells of sizeCellX x sizeCellY pixels
#
# Used to initialize afwMath::SpatialCellSet class 
#
sizeCellX: 128
sizeCellY: 128

######
# Number of stars to use in each SpatialCell cell
#
nStarPerCell: 1

######
# Number of iterations to reject bad footprints in the spatial fitting
#
maxSpatialIterations: 5

######
# Do we use PCA to reduce the dimensionality of the basis sets?
#
# This is particularly useful for delta-function kernels;
# functionally, all the Cells have their raw kernels determined, we
# run a PCA on these Kernels, and then re-fit the Cells using the
# eigenKernels which are then fit for spatially using the same
# technique as for the non-PCA delta-function and Alard-Lupton kernels
# 
# If this option is used, the first term (mean kernel) will have no
# spatial variation and the kernel sum will be conserved
#
usePcaForSpatialKernel: false

######
# Subtract off the mean feature before doing the Pca?
#
subtractMeanForPca: true

######
# How many principal components do you use in the decomposition?
#
# Note : this is defined to be the number to use *_in addition to_*
# the mean kernel, so in total you use N+1 basis functions for the
# decomposition.
# 
numPrincipalComponents: 4

######
# At what fraction of the eigenvalues do you cut off the expansion?
#
# This is currently not implemented
#
fracEigenVal : 0.95
