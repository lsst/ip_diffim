#<?cfg paf dictionary ?>
#
# Dictionary for makePsfMatchingKernel
#
definitions: {

    ######
    #
    # Warping for alignment of Exposures
    #
    warpingPolicy: {
        type: policy
        description: "Policy for image warping"
        dictionary: @@ip_diffim:/policy/WarpingPolicy.paf
        maxOccurs: 1
    }

    ######
    #
    # Detection for Psf-matching objects
    #
    detectionPolicy: {
        type: policy
        description: "Policy for detection of objects for psf matching"
        dictionary: @@ip_diffim:/policy/DetectionPolicy.paf
        maxOccurs: 1
    }

    ######
    #
    # Fitting for background using Afw
    #
    useAfwBackground: {
        type: bool
        description: "Use afw background subtraction instead of ip_diffim"
        maxOccurs: 1
        default: false
    }

    afwBackgroundPolicy: {
        type: policy
        description: "Policy in case diffim needs to do Afw background subtraction, e.g. for object detection
                      or when fitting for background using Afw exclusively (option useAfwBackground)"
        dictionary: @@ip_diffim:/policy/AfwBackgroundPolicy.paf
        maxOccurs: 1
    }

    ######
    #
    # Do you fit for background *at all* here
    #
    fitForBackground: {
        type: bool
        description: "Include terms (including kernel cross terms) for background"
        maxOccurs: 1
        default: false
    }

    ######
    #
    # Do we use createDefaultPolicy to modify terms based on FWHM?
    #
    scaleByFwhm: {
        type: bool
        description: "Scale kernelSize, alardSigGauss, and fpGrowPix by input Fwhm"
        maxOccurs: 1
        default: false
    }

    ######
    #
    # Basis set selection
    #
    kernelBasisSet: {
        type: string
        description: "Type of basis set for PSF matching kernel."
        maxOccurs: 1
        default: "alard-lupton"
        allowed: {
            value:        "alard-lupton"
            description:  "Alard-Lupton sum-of-gaussians basis set
                           * The first term has no spatial variation
                           * The kernel sum is conserved
                           * You may want to turn off 'usePcaForSpatialKernel'"
        }
        allowed: {
            value:        "delta-function"
            description:  "Delta-function kernel basis set
                           * You may enable the option useRegularization
                           * You should seriously consider usePcaForSpatialKernel, which will also
                             enable kernel sum conservation for the delta function kernels"
        }
    }


    ######
    #
    # Kernel size
    #
    kernelSize: {
        type: int
        description: "Number of rows/columns in the convolution kernel; odd-valued.
                      Modified by kernelSizeFwhmScaling if scaleByFwhm = true"
        maxOccurs: 1
        default: 19
    }

    kernelSizeFwhmScaling: {
        type: double
        description: "How much to scale the kernel size based on the Psf Fwhm;
                      should be smaller than fpGrowFwhmScaling.  Sets kernelSize."
        maxOccurs: 1
        default: 2.5
    }

    kernelSizeMin: {
        type: int
        description: "Minimum kernel dimensions"
        maxOccurs: 1
        default: 7
    }

    kernelSizeMax: {
        type: int
        description: "Maximum kernel dimensions"
        maxOccurs: 1
        default: 31
    }

    ######
    #
    # Alard-Lupton Basis Parameters
    #
    alardNGauss: {
        type: int
        description: "Number of gaussians in alard-lupton basis"
        maxOccurs: 1
        default: 3
    }

    alardDegGauss: {
        type: int
        description: "Degree of spatial modification of gaussians in alard-lupton basis"
        maxOccurs: 4
        default: 4 3 2
    }

    alardSigGauss: {
        type: double
        description: "Sigma in pixels of gaussians in alard-lupton basis (note: FWHM = 2.35 sigma). 
                      Scaled by alardSigFwhmScaling if scaleByFwhm = true"
        maxOccurs: 4
        default: 0.7 1.5 3.0
    }

    alardSigFwhmScaling: {
        type: double
        description: "Scaling of the alard-lupton gaussian sigmas.  Sets alardSigGauss"
        maxOccurs: 4
        default: 0.50 1.00 2.00
    }

    ######
    #
    # Delta Function Basis Parameters
    #
    useRegularization: {
        type: bool
        description: "Use regularization to smooth the delta function kernels"
        maxOccurs: 1
        default: true
    }
    
    regularizationType: {
        type: string
        description: "Type of regularization."
        maxOccurs: 1
        default: "centralDifference"
        allowed: {
            value:        "centralDifference"
            description:  "Penalize second derivative using 2-D stencil"
        }
        allowed: {
            value:        "forwardDifference"
            description:  "Penalize first, second, third or combination of derivatives"
        }
    }

    centralRegularizationStencil: {
        type: int
        description: "Type of stencil to approximate central derivative (for centralDifference only)"
        default: 9
        allowed: {
            value: 5
            description: "5-point stencil including only adjacent-in-x,y elements"
        }
        allowed: {
            value: 9
            description: "9-point stencil including diagonal elements"
        }
    }

    forwardRegularizationOrders: {
        type: int
        description: "Array showing which order derivatives to penalize (for forwardDifference only)"
        maxOccurs: 3
        default: 1 2
    }

    regularizationBorderPenalty: {
        type: double
        description: "Value of the penalty for kernel border pixels"
        maxOccurs: 1
        default: 3.0
    }

    regularizationScaling: {
        type: double
        description: "Fraction of the default lambda strength (N.R. 18.5.8) to use. 
                      somewhere around 1e-4 to 1e-5 seems to work.
                      some kernels need high freq power"
        maxOccurs: 1
        default: 1e-4
    }

    lambdaType: {
        type: string
        description: "How to choose the value of the regularization strength"
        maxOccurs: 1
        default: "absolute"
        allowed: {
            value:        "absolute"
            description:  "Use lambdaValue as the value of regularization strength"
        }
        allowed: {
            value:        "relative"
            description:  "Use lambdaValue as fraction of the default regularization strength (N.R. 18.5.8)"
        }
        allowed: {
            value:        "minimizeBiasedRisk"
            description:  "Minimize biased risk estimate"
        }
        allowed: {
            value:        "minimizeUnbiasedRisk"
            description:  "Minimize unbiased risk estimate"
        }
    }
    
    lambdaValue: {
        type: double
        description: "Value used for absolute or relative determinations of regularization strength"
        maxOccurs: 1
        default: 0.2
    }

    lambdaStepType: {
        type: string
        description: "If scan through lambda needed (minimizeBiasedRisk, minimizeUnbiasedRisk) use log
                      or linear steps"
        maxOccurs: 1
        default: "log"
        allowed: {
            value: "log"
            description: "Step in log intervals; e.g. lambdaMin, lambdaMax, lambdaStep = -1.0, 2.0, 0.1"
        }
        allowed: {
            value: "linear"
            description: "Step in linear intervals; e.g. lambdaMin, lambdaMax, lambdaStep = 0.1, 100, 0.1"
        }
    }
    
    lambdaMin: {
        type: double
        description: "If scan through lambda needed (minimizeBiasedRisk, minimizeUnbiasedRisk) 
                      start at this value.  If lambdaStepType = log:linear, suggest -1:0.1"
        maxOccurs: 1
        default: -1.0
    }
    
    lambdaMax: {
        type: double
        description: "If scan through lambda needed (minimizeBiasedRisk, minimizeUnbiasedRisk) 
                      stop at this value.  If lambdaStepType = log:linear, suggest 2:100"
        maxOccurs: 1
        default: 2.0
    }
    
    lambdaStep: {
        type: double
        description: "If scan through lambda needed (minimizeBiasedRisk, minimizeUnbiasedRisk) 
                      step in these increments.  If lambdaStepType = log:linear, suggest 0.1:0.1"
        maxOccurs: 1
        default: 0.1
    }

    ######
    #
    # Spatial modeling
    #
    spatialKernelType: {
        type: string
        description: "Type of spatial function for kernel"
        maxOccurs: 1
        default: "polynomial"
        allowed: {
            value:        "chebyshev1"
            description:  "Chebyshev polynomial of the first kind"
        }
        allowed: {
            value:        "polynomial"
            description:  "Standard x,y polynomial"
        }
    }

    spatialKernelOrder: {
        type: int
        description: "Spatial order of convolution kernel variation"
        maxOccurs: 1
        default: 1
    }

    spatialBgType: {
        type: string
        description: "Type of spatial function for kernel"
        maxOccurs: 1
        default: "polynomial"
        allowed: {
            value:        "chebyshev1"
            description:  "Chebyshev polynomial of the first kind"
        }
        allowed: {
            value:        "polynomial"
            description:  "Standard x,y polynomial"
        }
    }

    spatialBgOrder: {
        type: int
        description: "Spatial order of differential background variation"
        maxOccurs: 1
        default: 1
    }

    sizeCellX: {
        type: int
        description: "Size (rows) in pixels of each SpatialCell for spatial modeling"
        maxOccurs: 1
        default: 256
    }

    sizeCellY: {
        type: int
        description: "Size (columns) in pixels of each SpatialCell for spatial modeling"
        maxOccurs: 1
        default: 256
    }

    nStarPerCell: {
        type: int
        description: "Number of KernelCandidates in each SpatialCell to use in the spatial fitting"
        maxOccurs: 1
        default: 1
    }

    maxSpatialIterations: {
        type: int
        description: "Maximum number of iterations for rejecting bad KernelCandidates in the spatial fitting"
        maxOccurs: 1
        default: 3
    }

    ######
    #
    # Spatial modeling; Pca
    #
    usePcaForSpatialKernel: {
        type: bool
        description: "Use Pca to reduce the dimensionality of the kernel basis sets.
                      This is particularly useful for delta-function kernels.
                      Functionally, after all Cells have their raw kernels determined, we run 
                      a Pca on these Kernels, re-fit the Cells using the eigenKernels and then 
                      fit those for spatial variation using the same technique as for Alard-Lupton kernels.
                      If this option is used, the first term will have no spatial variation and the 
                      kernel sum will be conserved."
        maxOccurs: 1
        default: false
    }

    subtractMeanForPca: {
        type: bool
        description: "Subtract off the mean feature before doing the Pca"
        maxOccurs: 1
        default: true
    }

    numPrincipalComponents: {
        type: int
        description: "Number of principal components to use for Pca basis, including the 
                      mean kernel if requested."
        maxOccurs: 1
        default: 50
    }

    fracEigenVal: {
        type: double
        description: "At what fraction of the eigenvalues do you cut off the expansion.
                      Warning: not yet implemented"
        maxOccurs: 1
        default: 0.99
    }

    ######
    # 
    # What types of clipping of KernelCandidates to enable
    #
    singleKernelClipping: {
        type: bool
        description: "Do sigma clipping on each raw kernel candidate"
        maxOccurs: 1
        default: true
    }

    kernelSumClipping: {
        type: bool
        description: "Do sigma clipping on the ensemble of kernel sums"
        maxOccurs: 1
        default: true
    }

    spatialKernelClipping: {
        type: bool
        description: "Do sigma clipping after building the spatial model"
        maxOccurs: 1
        default: true
    }

    ######
    # 
    # Clipping of KernelCandidates based on diffim residuals
    #
    candidateResidualMeanMax: {
        type: double
        description: "Rejects KernelCandidates yielding bad difference image quality.
                      Represents average over pixels of (image/sqrt(variance))."
        maxOccurs: 1
        default: 0.25
    }

    candidateResidualStdMax: {
        type: double
        description: "Rejects KernelCandidates yielding bad difference image quality.
                      Represents stddev over pixels of (image/sqrt(variance))."
        maxOccurs: 1
        default: 1.50
    }

    useCoreStats: {
        type: bool
        description: "Use the core of the stamp for the quality statistics, instead of the entire footprint"
        maxOccurs: 1
        default: true
    }

    candidateCoreRadius: {
        type: int
        description: "Radius for calculation of stats in 'core' of KernelCandidate diffim.
                      Total number of pixels used will be (2*radius)**2. 
                      This is used both for 'core' diffim quality as well as ranking of
                      KernelCandidates by their total flux in this core"
        maxOccurs: 1
        default: 3
    }

    ######
    # 
    # Clipping of KernelCandidates based on kernel sum distribution
    #
    maxKsumSigma: {
        type: double
        description: "Maximum allowed sigma for outliers from kernel sum distribution.
                      Used to reject variable objects from the kernel model"
        maxOccurs: 1
        default: 3.0
    }

    ######
    # 
    # Clipping of KernelCandidates based on their matrices
    #
    checkConditionNumber: {
        type: bool
        description: "Test for maximum condition number when inverting a kernel matrix?
                      Anything above the value is not used and the candidate is set as BAD.        
                      Also used to truncate inverse matrix in estimateBiasedRisk.  However,
                      if you are doing any deconvolution you will want to turn this off, or use
                      a large maxConditionNumber"
        maxOccurs: 1
        default: false
    }

    maxConditionNumber: {
        type: double
        description: "Maximum condition number for a well conditioned matrix.
                      Suggested values:
                      * 5.0e6 for 'delta-function' basis
                      * 5.0e7 for 'alard-lupton' basis"
        maxOccurs: 1
        default: 5.0e7
    }

    conditionNumberType: {
        type: string
        description: "Use singular values (SVD) or eigen values (EIGENVALUE) to determine condition number"
        allowed: {
            value: "SVD"
            description: "Use singular values"
        }
        allowed: {
            value: "EIGENVALUE"
            description: "Use eigen values (faster)"
        }
        maxOccurs: 1
        default: "EIGENVALUE"
    }
    
    ######
    # 
    # Fitting of single kernel to object pair
    #
    iterateSingleKernel: {
        type: bool
        description: "Remake single kernel using better variance estimate after first pass?
                      Primarily useful when convolving a single-depth image, otherwise not necessary."
        maxOccurs: 1
        default: false
    }

    constantVarianceWeighting: {
        type: bool
        description: "Use constant variance weighting in single kernel fitting?
                      In some cases this is better for bright star residuals."
        maxOccurs: 1
        default: false
    }

    calculateKernelUncertainty: {
        type: bool
        description: "Calculate kernel and background uncertainties for each kernel candidate?
                      This comes from the inverse of the covariance matrix.
                      Warning: regularization can cause problems for this step."
        maxOccurs: 1
        default: false
    }
}
